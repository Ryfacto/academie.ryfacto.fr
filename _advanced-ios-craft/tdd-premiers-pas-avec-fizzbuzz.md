---
layout: article
image:
title: Test-Driven Development - Premiers pas avec FizzBuzz
description: aa
date: 13/07/2019
updated_at: 13/07/2019
published: true
beta: true
writing_time: 1
ahah: 1
technical_environment:
  swift: 5
  ios: 12.2
  xcode: 10.2.1
  appcode: 2019.1.4
comments:
---

Dans [l'article pr√©c√©dent](construire-une-architecture-emergente), je te parlais de l'importance des tests pour faire √©merger l'architecture.

J'√©voquais aussi le fait que [TDD permet d'√™tre plus productif](construire-une-architecture-emergente#automatiser-les-tests) en combattant l'id√©e re√ßue "√âcrire des tests revient √† √©crire plus de code, donc c'est plus lent".

> Tu m'as convaincu que TDD √©tait LA pratique √† apprendre. Mais comment je fais concr√®tement ?

Je vais te le montrer √† travers cet article justement !

Nous allons entrer dans le vif du sujet avec une approche par l'exemple comme l'a fait Kent Beck (le papa de TDD) le 8 novembre 2002 (17 ans d√©j√† !) lorsqu'il a publi√© son livre ["Test-Driven Development by Example"](https://amzn.to/2l8qHa3).

<!--more-->

## FizzBuzz

Le premier exemple se base sur un kata de code, le kata ["FizzBuzz"](http://kata-log.rocks/fizz-buzz-kata).

J'ai volontairement choisi un premier exemple qui ne refl√®te pas la r√©alit√© de ton quotidien pour que tu puisses te concentrer sur la pratique du TDD.

### √ânonc√©

- √âcris un programme qui affiche une ligne pour chaque nombre de 1 √† 100.
- Pour les multiples de `3`, affiche `Fizz` au lieu du nombre.
- Pour les multiples de `5`, affiche `Buzz` au lieu du nombre.
- Pour les nombres qui sont √† la fois des multiples de `3` et de `5`, affiche `FizzBuzz` au lieu du nombre.

Pr√™t √† relever le d√©fi ? C'est parti ! üí™

## √âtape 0 : je pr√©pare mon environnement

Qui dit √©crire des tests, dit pouvoir les lancer !

Je commence par cr√©er le projet : une app iOS "Single View App" avec des tests unitaires que j'appelle `TDDFizzBuzz`.

![Cr√©ation du Projet](tdd-intro-resources/images/0-project-creation.png)

Je v√©rifie ensuite que mes tests s'ex√©cutent correctement √† l'aide d'un petit `‚åòU` dans Xcode.

Je t'invite √† [t√©l√©charger le projet de d√©part](tdd-intro-resources/code/TDDFizzBuzz.zip). Comme √ßa tu pourras faire les diff√©rentes √©tapes avec moi.

Pour cet exemple je vais ex√©cuter les tests au sein de l'app.

Le probl√®me c'est que ce n'est pas performant lorsque l'on √©crit des tests pour une v√©ritable app.

Je te montrerai dans le prochain article (o√π nous allons cr√©er une v√©ritable app iOS en TDD), comment faire pour ex√©cuter les tests ind√©pendamment de l'app. [Inscris-toi √† la newsletter](signup) pour ne pas le louper !

## √âtape 1 : quels sont les comportements attendus ?

> Whaaaaat ? Je croyais que la premi√®re √©tape de TDD √©tait le test rouge ! Mais l√† tu...

Hola, hola ! Du calme mon ami(e) !

Je me permets une petite apart√©.

Bien que TDD existe depuis longtemps et soit tr√®s bien document√© par Kent Beck dans son livre.

Il s'av√®re que c'est une pratique qui a √©t√© interpr√©t√©e, d√©tourn√©e, galvaud√©e, et j'en passe.

Je tiens √† revenir aux id√©es originales pr√©sent√©es dans le livre.

Et il se trouve, aussi √©tonamment que cela puisse para√Ætre, que la premi√®re chose √† faire selon l'auteur soit de lister les __comportements__ attendus.

J'insiste bien sur le terme __comportement__.

En d'autres termes, quels sont les tests √† √©crire pour sp√©cifier ces comportements ?

_Je t'invite √† faire l'exercice de ton c√¥t√©. Liste tous les tests (comportements !) pour `FizzBuzz`._

...

...

...

C'est bon ?

Voici ma liste :

<table>
  <tr><td>100 -> [1, 2, Fizz, 4, Buzz, Fizz, ... ]</td></tr>
  <tr><td>creation</td></tr>
  <tr><td>3 -> [1, 2, Fizz]</td></tr>
  <tr><td>5 -> last == Buzz</td></tr>
  <tr><td>15 -> last == FizzBuzz</td></tr>
  <tr><td>0 -> []</td></tr>
  <tr><td>-1 -> []</td></tr>
  <tr><td>1 -> [1]</td></tr>
</table>

J'ai pour habitude d'√©crire cette liste en commentaire dans le code de la classe de test que je suis en train d'√©crire.

Le plus important est d'avoir cette liste sous les yeux car nous allons la mettre √† jour continuellement quand d'autres tests nous viendront en t√™te ou quand nous aurons fini d'√©crire un test.

## √âtape 2 : dans quel ordre j'√©cris les tests ?

J'utilise un algorithme simple pour d√©terminer l'ordre de priorit√©.

1. Quel test me fera √©crire le moins de code ? Autrement dit, quel est le test le plus simple √† faire passer ?
2. Ai-je des cas √† la marge √† g√©rer ? Exemple : string vide, valeurs nil, liste vide, etc.

_√Ä toi de jouer ! Priorise ta liste._

...

...

...

Job done ?

Moi oui ! Voici ma liste prioris√©e avec quelques explications :

<table>
  <thead><tr><th>Test</th><th>Pourquoi ?</th></tr></thead>
  <tr><td>creation</td><td>Me poussera √† simplement cr√©er le type.</td></tr>
  <tr><td>0 -> []</td><td>Cas √† la marge</td></tr>
  <tr><td>-1 -> []</td><td>Cas √† la marge</td></tr>
  <tr><td>1 -> [1]</td><td>Cas simple : afficher le num√©ro sous forme de string</td></tr>
  <tr><td>3 -> [1, 2, Fizz]</td><td>Premi√®re r√®gle m√©tier</td></tr>
  <tr><td>5 -> last == Buzz</td><td>Deuxi√®me r√®gle m√©tier</td></tr>
  <tr><td>15 -> last == FizzBuzz</td><td>Troisi√®me r√®gle m√©tier</td></tr>
  <tr><td>100 -> [1, 2, Fizz, 4, Buzz, Fizz, ... ]</td><td>Test d'acceptance</td></tr>
</table>

> Pourquoi commencer par les tests les plus simples et ceux √† la marge ?

Tr√®s bonne question !

Si je commence par les tests concernant les r√®gles m√©tiers, je risque de me retrouver bloquer.

Je risque de devoir impl√©menter tout l'algo, ou une grosse partie, d'un coup !

Dans un prochain article, je te montrerai un exemple qui illustre un blocage si on ne priorise pas correctement. Pour ne pas le rater, [inscris-toi √† la newsletter !](signup)

## √âtape 3 : un peu de conception

Qui a dit que TDD voulait dire foncer t√™te baiss√©e sans concevoir ?

Cette phase est tr√®s importante.

J'imagine l'API (Application Programming Interface) la plus simple possible qui me permettra d'√©crire les premiers tests.

Je peux faire cette exercice dans ma t√™te ou sur tableau blanc.

Je peux en discuter avec mon pair si je travaille en pair programming.

_Je t'invite √† concevoir cette API avant de continuer ta lecture._

...

...

...

Voici ce que j'ai imagin√©, sur tableau blanc en utilisant un peu d'UML.

![UML FizzBuzz](tdd-intro-resources/images/1-uml.jpg)

## √âtape 4 : le premier test rouge (RED)

> Enfin !

Le suspens √©tait √† son comble mais nous y sommes !

L'√©criture du premier test rouge !

### Le test marche-pied de "cr√©ation"

Si ce n'est pas d√©j√† fait, [t√©l√©charge le projet de d√©part](tdd-intro-resources/code/TDDFizzBuzz.zip).

Afin de bien d√©marrer, supprime le fichier __TDDFizzBuzzTests.swift__ qui servait simplement √† v√©rifier l'environnement.

Cr√©e ensuite un groupe __FizzBuzz__ dans le groupe __TDDFizzBuzz__.

Cr√©e ensuite le premier fichier de test __FizzBuzz_Spec.swift__ dans le groupe __FizzBuzz__ et veille bien √† l'ajouter √† la target __TDDFizzBuzzTests__.

_(Pour je ne sais quelle raison, Xcode propose de cr√©er un Bridging Header. R√©ponds "Don't create" et tout ira bien !)_

Ensuite √©cris le code suivant dans __FizzBuzz_Spec.swift__ :

{% highlight swift %}
import XCTest
@testable import TDDFizzBuzz

class FizzBuzz_Spec: XCTestCase {

}
{% endhighlight %}

Et enfin le premier test √† l'int√©rieur de la classe __FizzBuzz_Spec__ :

{% highlight swift %}
func test_Creation() {
  _ = FizzBuzz()
}
{% endhighlight %}

> √áa ne compile m√™me pas !

Parfait ! Un code qui ne compile pas √©quivaut √† un test qui √©choue.

C'est la phase __RED__ de TDD. J'√©cris d'abord un test qui √©choue.

J'utilise ici un type qui n'existe pas encore, cette technique a √©t√© nomm√©e __programming by wishful thinking__ par Abelson, Harold et Gerald Sussman dans leur ouvrage : _Structure and Interpretations of Computer Programs_, MIT Press, 1996 (ISBN : 978-0262011532).

Cela nous aide √† concevoir les API les plus simples possibles et √† valider notre conception initiale.

## √âtape 5 : je fais passer le test le plus vite possible (GREEN)

Fais passer le test en cr√©ant une `struct` __FizzBuzz__ juste au-dessus de la classe de test dans le fichier __FizzBuzz_Spec.swift__.

{% highlight swift %}
struct FizzBuzz {

}
{% endhighlight %}

Relance le test avec `‚åòU`.

Il passe ! C'est la phase __GREEN__ de TDD : je fais passer le test le plus vite possible.

> Il est un peu inutile ce test non ?

Il peut sembler inutile, il n'emp√™che qu'il m'a pouss√© √† cr√©er la `struct`, il m'a permis de mettre le pied √† l'√©trier.

Il m'a permis...de progresser !

C'est un test que l'on appelle "test marche-pied".

En TDD, tu peux avancer par petites √©tapes, les anglophones parlent de "baby steps".

Pour autant, ce n'est pas parce que tu peux le faire que tu vas toujours le faire.

Il m'arrive de sauter ce test pour aller plus vite.

Ce n'est pas "interdit" par la pratique de TDD.

Mais je sais que si je le souhaite, je peux ralentir pour y aller plus progressivement.

## √âtape 6 (ma pr√©f√©r√©e) : j'am√©liore la structure ! (REFACTORING)

Posons-nous la question suivante : _quelles crimes de conception avons-nous commis ?_

> Sur un code si simple, avons-nous vraiment commis des crimes de conception ?

Oui, un petit crime en r√©alit√©. üòâ

Je te laisse un petit temps de reflexion.

...

...

...

Alors ?

> Ah je sais ! `FizzBuzz` est inutilisable dans le code de production puisqu'elle est dans le fichier de test !

Exactement ! Bien jou√© !

Du coup, comment r√®gle-t-on le soucis ?

> On cr√©e un nouveau fichier pour y mettre `FizzBuzz`.

Parfait !

Cr√©e le fichier __FizzBuzz.swift__ juste √† c√¥t√© du fichier de test.

Maintenant d√©place la `struct FizzBuzz` dans ce fichier et relance les tests.

## √âtape 7 : je mets √† jour la liste

J'ai fini d'√©crire le premier test, je peux donc mettre √† jour la liste en retirant ce test.

<table>
  <tr><td>0 -> []</td></tr>
  <tr><td>-1 -> []</td></tr>
  <tr><td>1 -> [1]</td></tr>
  <tr><td>3 -> [1, 2, Fizz]</td></tr>
  <tr><td>5 -> last == Buzz</td></tr>
  <tr><td>15 -> last == FizzBuzz</td></tr>
  <tr><td>100 -> [1, 2, Fizz, 4, Buzz, Fizz, ... ]</td></tr>
</table>

üéâ Tu viens de terminer ton premier cycle TDD, bravo !

R√©sumons :
- √©tape 1 : je cr√©e ou mets √† jour la liste des __comportements attendus__,
- √©tape 2 : j'ordonne la liste en commen√ßant par les tests les plus simples (ceux qui me feront √©crire le moins de code) ainsi que les cas √† la marge ; pour √©viter de me retrouver bloquer,
- √©tape 3 : je fais juste assez de conception pour m'aider √† √©crire les tests, et surtout le premier,
- √©tape 4 : j'√©cris le premier test en utilisant du code qui n'existe pas, c'est la phase __RED__,
- √©tape 5 : je fais passer le test sans me pr√©occuper des horreurs de conception que je fais, c'est la phase __GREEN__,
- √©tape 6 : je nettoie les dites horreurs, c'est la phase __REFACTORING__,
- √©tape 7 : je mets √† jour ma liste et je recommence tant qu'elle n'est pas vide !

> Pourquoi ne pas √©crire directement du code bien con√ßu ?

Certains pratiquants du TDD le font.

Il m'arrive aussi de le faire de temps en temps.

Il faut cependant avoir conscience que vouloir _"faire correctement tout de suite"_ c'est prendre le risque de faire de la sur-ing√©nierie, d'√©crire du code au cas o√π, du code qui n'est pas requis par un test qui √©choue.

Et puis, c'est plus difficile de faire _bien_ tout de suite.

J'aime bien cette id√©e d'aller tr√®s vite en __GREEN__ sans se pr√©occuper de la conception.

Puis dans la phase de __REFACTORING__ prendre du recul, de la hauteur et vraiment me concentrer sur la bonne conception.

Si tu d√©butes en TDD, je t'encourage vivement √† y aller doucement.

## Et le cycle recommence !

### FizzBuzz "jusqu'√† 0"

Modifie __FizzBuzz_Spec.swift__ pour y ajouter ce test :

{% highlight swift %}
func test_FizzBuzz_up_to_0_is_an_empty_list() {
  let fizzBuzz = FizzBuzz()
  let result = fizzBuzz.upTo(0)
  let expected: [String] = []
  XCTAssertEqual(expected, result)
}
{% endhighlight %}

Lance les tests. Erreur de compilation !

Ajoute la m√©thode `upTo` √† `FizzBuzz`.

{% highlight swift %}
func upTo(_ n: Int) -> [String] {
  fatalError("upTo(n:) has not been implemented")
}
{% endhighlight %}

Relance les tests. √âchec √† nouveau, quelle tristesse !

Non, un test qui √©choue c'est du progr√®s !

Aller, on ne se d√©courage pas, on fait passer le test le plus vite possible !

Met √† jour la m√©thode `upTo` :

{% highlight swift %}
func upTo(_ n: Int) -> [String] {
  return []
}
{% endhighlight %}

Et relance les tests une nouvelle fois (tu comprends maintenant pourquoi ils doivent √™tre rapide !).

Ils passent !

> Youpi ! Test suivant !

Hum hum...

> ...je voulais dire : refactoring !

Ah ! Je pr√©f√®re √ßa !

> Quels crimes avons-nous commis ?

J'allais te le demander !

> Je regarde le code dans `FizzBuzz`, √ßa m'a l'air tr√®s bien, je ne vois pas quoi am√©liorer...

Et dans les tests ?

> Quoi ? On doit aussi refactorer les tests ?

Et comment ! C'est encore plus important que le code de production !

Les tests sont-ils bien con√ßus selon toi ?

Y'a-t-il de la duplication ?

...

...

...

> Oh c'est difficile, je ne sais pas !

Ok ok je vais t'aider !

Il y a un test qui est devenu inutile...

...notre test "marche-pied" !

Tu peux donc le supprimer, il s'agit de la m√©thode `test_Creation`. _Whoop! Supprim√©e!_

> Ensuite on met √† jour la liste !

Extact !

<table>
  <tr><td>-1 -> []</td></tr>
  <tr><td>1 -> [1]</td></tr>
  <tr><td>3 -> [1, 2, Fizz]</td></tr>
  <tr><td>5 -> last == Buzz</td></tr>
  <tr><td>15 -> last == FizzBuzz</td></tr>
  <tr><td>100 -> [1, 2, Fizz, 4, Buzz, Fizz, ... ]</td></tr>
</table>

### FizzBuzz "jusqu'√† -1"

Je me pose la question si je dois r√©ellement √©crire un test pour celui-ci.

Ne pourrais-je pas g√©rer ce cas marginal autrement ?

√Ä ton avis ?

...

...

...

> Le compilateur ! On met un `UInt` au lieu d'un `Int` pour le param√®tre `n` !

Eur√©ka ! Tr√®s bonne id√©e !

Modifie la m√©thode `upTo` comme ceci :

{% highlight swift %}
func upTo(_ n: UInt) -> [String] {
  return []
}
{% endhighlight %}

Relance les tests pour √™tre s√ªr.

√áa marche toujours !

On vient de s'√©pargner un test, donc du code √† maintenir, g√©nial ! Merci le syst√®me de type !

<table>
  <tr><td>1 -> [1]</td></tr>
  <tr><td>3 -> [1, 2, Fizz]</td></tr>
  <tr><td>5 -> last == Buzz</td></tr>
  <tr><td>15 -> last == FizzBuzz</td></tr>
  <tr><td>100 -> [1, 2, Fizz, 4, Buzz, Fizz, ... ]</td></tr>
</table>

### FizzBuzz "jusqu'√† 1"

Ajoute le test suivant :

{% highlight swift %}
func test_FizzBuzz_up_to_1_is_a_list_containing_1_as_string() {
  let fizzBuzz = FizzBuzz()
  let result = fizzBuzz.upTo(1)
  let expected = [ "1" ]
  XCTAssertEqual(expected, result)
}
{% endhighlight %}

Lance les tests. Le dernier √©choue !

Modifie le code pour le faire passer :

{% highlight swift %}
func upTo(_ n: UInt) -> [String] {
  if n == 0 {
    return []
  }

  return [ "1" ]
}
{% endhighlight %}

Relance les tests. Ils passent !

> REFACTORING !!!

WOW! Oui c'est √ßa haha !

> Y'a une duplication ! C'est p√¥ bien !

Effectivement, le `"1"` est dupliqu√© !

Il est pr√©sent dans le code de test, et dans le code de production.

Nous sommes donc forc√©s de le supprimer √† un des deux endroits et de le remplacer par autre chose sans rien casser.

Nous allons __g√©n√©raliser__ le code de production pour supprimer la duplication sans rien casser.

> Comment √ßa "g√©n√©raliser" ?

G√©n√©raliser revient √† supprimer ce qui est sp√©cifique, ici `"1"` en utilisant des variables.

Quelle variable peux-tu utiliser dans ce cas pr√©cis pour remplacer `"1"` dans la m√©thode `upTo` ?

...

...

...

> `n` !

C'est √ßa ! Modifie le code de `upTo` comme ceci :

{% highlight swift %}
func upTo(_ n: UInt) -> [String] {
  if n == 0 {
    return []
  }

  return [ "\(n)" ]
}
{% endhighlight %}

Relance les tests. Ils passent toujours !

Ceci est tr√®s int√©ressant et illustre une des propri√©t√©s des __bons tests__.

<p class="highlight">
  Au fur et √† mesure que les tests deviennent <strong>sp√©cifiques</strong>, le code de production devient <strong>g√©n√©rique</strong>.
</p>

Il y a encore de la duplication, mais dans les tests cette fois.

Simplifions les gr√¢ce √† trois refactorings : [_extract variable_](https://refactoring.guru/extract-variable), [_extract method_](https://refactoring.guru/extract-method) et [_inline temp_](https://refactoring.guru/inline-temp).

Premi√®rement fais un _extract variable_ des param√®tres en entr√©e de `upTo` dans les deux tests :

{% highlight swift %}
func test_FizzBuzz_up_to_0_is_an_empty_list() {
  // ...
  let input: UInt = 0
  let result = fizzBuzz.upTo(input)
  // ...
}

func test_FizzBuzz_up_to_1_is_a_list_containing_1_as_string() {
  // ...
  let input: UInt = 1
  let result = fizzBuzz.upTo(input)
  // ...
}
{% endhighlight %}

Ensuite, fais remonter les variables `input` et `expected` en haut de chaque m√©thode de test :

{% highlight swift %}
func test_FizzBuzz_up_to_0_is_an_empty_list() {
  let input: UInt = 0
  let expected: [String] = []
  // ...
}

func test_FizzBuzz_up_to_1_is_a_list_containing_1_as_string() {
  let input: UInt = 1
  let expected = [ "1" ]
  // ...
}
{% endhighlight %}

Et enfin un _extract method_ des trois derni√®res lignes :

{% highlight swift %}
func test_FizzBuzz_up_to_0_is_an_empty_list() {
  let input: UInt = 0
  let expected: [String] = []
  assertThatFizzBuzz(upTo: input, is: expected)
}

func test_FizzBuzz_up_to_1_is_a_list_containing_1_as_string() {
  let input: UInt = 1
  let expected = [ "1" ]
  assertThatFizzBuzz(upTo: input, is: expected)
}

// 1.
private func assertThatFizzBuzz(upTo n: UInt, is expected: [String], line: UInt = #line) {
  let fizzBuzz = FizzBuzz()
  let result = fizzBuzz.upTo(n)
  XCTAssertEqual(expected, result, line: line)
}
{% endhighlight %}

1. Tu noteras que j'ai ajout√© un param√®tre `line`, avec la valeur sp√©ciale `#line`. Cela permet d'indiquer √† Xcode √† quelle ligne aller lorsque l'assertion √©choue et que l'on clique sur le test qui a √©chou√©. Sans ce param√®tre, Xcode nous emm√®nerait dans la m√©thode `assertThatFizzBuzz...` et on devrait aller nous-m√™me dans le code appelant la m√©thode. Ce qui est tr√®s ennuyeux !

Et enfin, ultime √©tape, tu peux _inline temp_ les variables `input` & `expected` :

{% highlight swift %}
func test_FizzBuzz_up_to_0_is_an_empty_list() {
  assertThatFizzBuzz(upTo: 0, is: [])
}

func test_FizzBuzz_up_to_1_is_a_list_containing_1_as_string() {
  assertThatFizzBuzz(upTo: 1, is: [ "1" ])
}

private func assertThatFizzBuzz(upTo n: UInt, is expected: [String], line: UInt = #line) {
  let fizzBuzz = FizzBuzz()
  let result = fizzBuzz.upTo(n)
  XCTAssertEqual(expected, result, line: line)
}
{% endhighlight %}

Un petit run des tests pour v√©rifier qu'on n'a rien cass√© au passage...

...et √ßa marche ! Merveilleux !

### FizzBuzz "jusqu'√† 2"

Je viens de penser √† un nouveau test.

Un test qui nous obligera √† boucler : FizzBuzz jusqu'√† 2 !

Je l'ajoute en haut de la liste :

<table>
  <tr><td>2 -> [1, 2]</td></tr>
  <tr><td>3 -> [1, 2, Fizz]</td></tr>
  <tr><td>5 -> last == Buzz</td></tr>
  <tr><td>15 -> last == FizzBuzz</td></tr>
  <tr><td>100 -> [1, 2, Fizz, 4, Buzz, Fizz, ... ]</td></tr>
</table>

Ajoute le test suivant :

{% highlight swift %}
func test_FizzBuzz_up_to_2_is_a_list_containing_1_and_2_as_string() {
  assertThatFizzBuzz(upTo: 2, is: [ "1", "2" ])
}
{% endhighlight %}

Gr√¢ce aux refactorings d'avant, ce test a √©t√© tr√®s simple √† √©crire !

De plus, il est on ne peut plus parlant et clair.

> Toujours prendre soin de ses tests hein ?

Toujours ! üëç

> On le fait passer ?

Avec plaisir ! Mais comment ?

...

...

...

> Comme √ßa !

{% highlight swift %}
func upTo(_ n: UInt) -> [String] {
  if n == 0 {
    return []
  }

  if n == 2 {
    return [ "1", "\(n)" ]
  }

  return [ "\(n)" ]
}
{% endhighlight %}

Bien jou√© ! Le probl√®me c'est que ce n'est pas tr√®s propre...

> C'est pour √ßa que la phase de Refactoring existe !

üò¢ Je suis si fier de toi !

> Supprimons les duplications en g√©n√©ralisant. Le `"1"` peut devenir `"\(n-1)"` dans un premier temps.

{% highlight swift %}
func upTo(_ n: UInt) -> [String] {
  if n == 0 {
    return []
  }

  if n == 2 {
    return [ "\(n-1)", "\(n)" ]
  }

  return [ "\(n)" ]
}
{% endhighlight %}

Hum...je vois un sch√©ma qui se r√©p√®te gr√¢ce √† ce refactoring.

√áa m'a tout l'air d'√™tre un bon candidat pour une boucle.

__En plus, une boucle est la g√©n√©ralisation d'un if !__

{% highlight swift %}
func upTo(_ n: UInt) -> [String] {
  if n == 0 {
    return []
  }

  var result: [String] = []

  for i in (1...n) {
    result.append("\(i)")
  }

  return result
}
{% endhighlight %}

D√©j√† mieux !

> On peut le faire en plus "prog fonctionnelle" please ? ü§ó

Oh oui, ce `var` me d√©range aussi, mais comment ?

> `map` !

{% highlight swift %}
func upTo(_ n: UInt) -> [String] {
  if n == 0 {
    return []
  }

  return (1...n).map { "\($0)" }
}
{% endhighlight %}

> Woohoo ! üéâ

Je me demande...Est-ce que le premier `if` est toujours n√©cessaire ?

> On peut regarder la doc de `map` sur les `ClosedRange` pour v√©rifier ?

Trop long ! Je vais simplement virer ce `if` et v√©rifier si mes tests passent toujours !

> Ah ouais pas b√™te... üòÖ

{% highlight swift %}
func upTo(_ n: UInt) -> [String] {    
  return (1...n).map { "\($0)" }
}
{% endhighlight %}

‚ùå __FAIL__

Oups, √ßa ne marche pas !

> Au moins nous avons pu v√©rifier en un rien de temps !

Oui, c'est ce qui est int√©ressant avec de bons tests, on peut v√©rifier nos id√©es rapidement !

Continuons...

Le test √©choue avec l'erreur suivante : `Fatal error: Can't form Range with upperBound < lowerBound`

Effectivement, j'essaye de cr√©er un `Range` avec `n = 0` soit `(1...0)` et ce n'est pas possible.

Et si je mettais `(0...n)` plut√¥t ?

{% highlight swift %}
func upTo(_ n: UInt) -> [String] {
  return (0...n).map { "\($0)" }
}
{% endhighlight %}

‚ùå __FAIL__

> Tous les tests √©chouent !

Effectivement, mais les erreurs sont claires :
- `XCTAssertEqual failed: ("[]") is not equal to ("["0"]")`
- `XCTAssertEqual failed: ("["1"]") is not equal to ("["0", "1"]")`
- `XCTAssertEqual failed: ("["1", "2"]") is not equal to ("["0", "1", "2"]")`

Un magnifique `"0"` est ajout√©.

Cela est d√ª au fait que mon range d√©marre par `0`.

Et si j'ignorais simplement le premier √©l√©ment de mon range ?

{% highlight swift %}
func upTo(_ n: UInt) -> [String] {
  return (0...n).dropFirst(1).map { "\($0)" }
}
{% endhighlight %}

‚úÖ __SUCCESS__

Aaaah voil√† qui est mieux !

> Une ligne de code, waouh !

Et tout √ßa gr√¢ce aux tests qui v√©rifient la non-r√©gression !

### R√®gle m√©tier : "Pour les nombres non multiples de `3` ou `5`, affiche le nombre"

Je viens de me rendre compte que ma checklist ne refl√®te pas vraiment les r√®gles m√©tiers, je la mets donc √† jour.

<table>
  <tr><td>Pour les nombres non multiples de <code>3</code> ou <code>5</code>, affiche le nombre</td></tr>
  <tr><td>3 -> [1, 2, Fizz]</td></tr>
  <tr><td>Pour les multiples de <code>3</code>, affiche <code>Fizz</code> au lieu du nombre</td></tr>
  <tr><td>5 -> last == Buzz</td></tr>
  <tr><td>Pour les multiples de <code>5</code>, affiche <code>Buzz</code> au lieu du nombre</td></tr>
  <tr><td>15 -> last == FizzBuzz</td></tr>
  <tr><td>Pour les multiples de <code>15</code>, affiche <code>FizzBuzz</code> au lieu du nombre</td></tr>
  <tr><td>Afficher les nombres de 1 √† 100</td></tr>
</table>

Voil√† aussi une belle illustration des bienfaits de TDD.

<p class="highlight">
  Pour √©crire de bons tests, je dois capture <strong>fid√®lement</strong> le besoin.
</p>

Mon envie d'avoir une bonne suite de tests, une bonne __documentation__ me pousse √† me concentrer sur le besoin.

Souvent, en √©crivant des tests, je me rends compte qu'il me manque des informations.

Je d√©couvre des cas d'usages (des cas d'erreurs la plupart du temps), pour lesquels j'ai besoin de questionner les utilisateurs & utilisatrices (ou le Product Owner).

R√©visons nos deux derniers tests :
- `test_FizzBuzz_up_to_1_is_a_list_containing_1_as_string`
- `test_FizzBuzz_up_to_2_is_a_list_containing_1_and_2_as_string`

Ce sont deux tests qui sont des exemples v√©rifiant la premi√®re r√®gle m√©tier : __"Pour les nombres non multiples de `3` ou `5`, affiche le nombre".__

Dans un soucis de __bonne documentation__ (je me r√©p√®te mais c'est __important__ !), ces deux tests me d√©rangent car ils ne communiquent pas efficacement la r√®gle m√©tier.

Comment pourrions-nous nommer un test unique qui communique efficacement cette r√®gle m√©tier ?

...

...

...

> Hum, que penses-tu de `test_Numbers_not_multiple_of_3_or_5_are_displayed_as_is` ?

√áa me semble parfait, bien jou√© !

Quel serait le contenu de cette m√©thode de test ?

> Pourquoi pas ceci :

{% highlight swift %}
func test_Numbers_not_multiple_of_3_or_5_are_displayed_as_is() {
  assertThatFizzBuzz(upTo: 2, is: [ "1", "2" ])
}
{% endhighlight %}

Pas mal...

Le probl√®me c'est qu'on ne g√®re que les nombres jusqu'√† `2`.

C'est un test assez limit√©.

> Ok, alors ceci peut-√™tre ?

{% highlight swift %}
func test_Numbers_not_multiple_of_3_or_5_are_displayed_as_is() {
  assertThatFizzBuzz(upTo: 10, is: [ "1", "2", "3", "4", "5", "6", "7", "8", "9", "10" ])
}
{% endhighlight %}

L√† on teste jusqu'√† `10`, c'est mieux ; le probl√®me c'est que les prochaines r√®gles m√©tiers vont faire √©chouer ce test.

__Or on ne veut pas √©crire de tests "faux".__

Il serait pertinent, dans un premier temps, de v√©rifier que certains nombres sont bien affich√©s tels quels.

Que penses-tu ce ceci ?

{% highlight swift %}
func test_Numbers_not_multiple_of_3_or_5_are_displayed_as_is() {
  assertThatFizzBuzz(upTo: 1, endsWith: "1")
  assertThatFizzBuzz(upTo: 2, endsWith: "2")
  assertThatFizzBuzz(upTo: 4, endsWith: "4")
  // ...
  assertThatFizzBuzz(upTo: 10213, endsWith: "10213")
}

private func assertThatFizzBuzz(upTo n: UInt, endsWith expected: String, line: UInt = #line) {
  let fizzBuzz = FizzBuzz()
  let result = fizzBuzz.upTo(n)
  XCTAssertEqual(expected, result.last, line: line)
}
{% endhighlight %}

> Mouais...√ßa va nous faire un test long comme le bras √ßa ! üòï
> Et tu ne v√©rifies pas que la liste retourn√©e est bonne, juste le dernier √©l√©ment.

Tu as raison...

Pour ta deuxi√®me remarque j'ajoute un test √† ma liste : __FizzBuzz jusqu'√† un certain nombre retourne une liste de la taille de ce nombre__.

Concernant ta premi√®re remarque, nous pouvons g√©n√©raliser en faisant une boucle avec nos exemples.

Comme ceci :

{% highlight swift %}
func test_Numbers_not_multiple_of_3_or_5_are_displayed_as_is() {
  let numbers: [UInt] = [ 1, 2, 4, 10213 ]
  for n in numbers {
    assertThatFizzBuzz(upTo: n, endsWith: "\(n)")
  }
}
{% endhighlight %}

> Excellent !

Oui √ßa me pla√Æt assez...

> Mais...?

Mais j'ai l'impression de r√©√©crire l'algo dans mes tests !

> Et...c'est grave √ßa ?

Oui car cela introduit de la duplication et du couplage entre les tests et le code de prod !

Modifions le test pour √©viter cela :

{% highlight swift %}
func test_Numbers_not_multiple_of_3_or_5_are_displayed_as_is() {
  let expectations: [UInt: String] = [ 1: "1", 2: "2", 4: "4", 10213: "10213" ]
  for (n, expected) in expectations {
    assertThatFizzBuzz(upTo: n, endsWith: expected)
  }
}
{% endhighlight %}

Beaucoup mieux !

Passons maintenant au refactoring.

Je vois plusieurs duplications :
1. il y a des tests redondants,
2. il y a de la duplication dans les deux m√©thodes d'assertions.

Commen√ßons par le 1., on peut supprimer les tests suivants :
- `test_FizzBuzz_up_to_1_is_a_list_containing_1_as_string`
- `test_FizzBuzz_up_to_2_is_a_list_containing_1_and_2_as_string`

Et enfin le 2., on cr√©e une nouvelle m√©thode pour factoriser le code similaire dans nos deux assertions :

{% highlight swift %}
private func assertThatFizzBuzz(upTo n: UInt, is expected: [String], line: UInt = #line) {
  let result = fizzBuzz(upTo: n)
  XCTAssertEqual(expected, result, line: line)
}

private func assertThatFizzBuzz(upTo n: UInt, endsWith expected: String, line: UInt = #line) {
  let result = fizzBuzz(upTo: n)
  XCTAssertEqual(expected, result.last, line: line)
}

private func fizzBuzz(upTo n: UInt) -> [String] {
  let fizzBuzz = FizzBuzz()
  return fizzBuzz.upTo(n)
}
{% endhighlight %}

Done !

Le fait de tester le comportement de `FizzBuzz` avec des valeurs pr√©d√©finies est une approche __bas√©e sur l'exemple__.

Elle pr√©sente l'avantage d'√™tre simple √† mettre en ≈ìuvre et suffit la plupart du temps.

L'inconv√©nient est que sur certains algorithmes, nous pouvons difficilement couvrir tous les exemples efficacement. Un de ces algorithmes est celui du kata [Roman Numerals](http://kata-log.rocks/roman-numerals-kata) o√π il faut transformer des nombres romains en nombres arabes.

Autre inconv√©nient : cette approche n'offre pas de "preuve" au sens math√©matique. Nos tests prouvent uniquement que notre programme fonctionne pour les exemples choisis.

_Pour aller plus loin_, tu peux aller fouiller du c√¥t√© de l'approche bas√©e sur les propri√©t√©s : le __property-based testing__. Pour cela, nous utilisons notamment des outils comme [SwiftCheck](https://github.com/typelift/SwiftCheck). Je pr√©vois de r√©viser `FizzBuzz` en utilisant SwiftCheck dans un prochain article, pour ne pas le manquer, [inscris-toi √† la newsletter !](signup)

### Propri√©t√© : la taille de la liste

J'ai ajout√© √† ma liste le test suivant : __FizzBuzz jusqu'√† un certain nombre retourne une liste de la taille de ce nombre__.

Il est maintenant temps de l'impl√©menter !

{% highlight swift %}
func test_Result_list_is_of_the_same_size_as_requested_upper_bound() {
  let fizzBuzz = FizzBuzz()
  let result = fizzBuzz.upTo(0)
  XCTAssertEqual(0, result.count)
}
{% endhighlight %}

L√† nous g√©rons le cas `0`, allons plus loin en restant dans l'approche par l'exemple pour tester jusqu'√† 100.

{% highlight swift %}
func test_Result_list_is_of_the_same_size_as_requested_upper_bound() {
  let fizzBuzz = FizzBuzz()
  for n in 0...100 {
    let result = fizzBuzz.upTo(UInt(n))
    XCTAssertEqual(n, result.count)
  }
}
{% endhighlight %}

> J'ai quand m√™me une interrogation par rapport √† TDD...

Je t'√©coute.

> En √©crivant ce test, nous ne sommes pas pass√©s par la phase __RED__. C'est encore du TDD du coup ?

Tr√®s bonne remarque !

Pourquoi est-il utile de passer par la phase __RED__ ?

> Pour v√©rifier que notre test est utile et s'assurer que son √©chec donne assez d'informations pour nous aider √† r√©gler l'√©ventuel probl√®me.

Exactement !

Je prends le risque ici d'√©crire un test inutile et je ne v√©rifie pas les informations li√©es √† son √©ventuel √©chec.

Et √† quoi servent les tests ?

> √Ä v√©rifier la non-r√©gression et √† guider la conception.

Mais encore...?

> Heu...ah oui ! Les tests servent de __documentation des comportements attendus__ !

Tout √† fait !

Je souhaite sp√©cifier les comportements attendus ! Un des comportements que j'attends est que `FizzBuzz` me retourne une bonne liste de `String` donc il me faut un test pour le sp√©cifier.

Cela suffit √† justifier l'utilit√© de ce test.

Concernant le message d'erreur, je peux forcer l'√©chec de ce test en modifiant le code de production comme ceci :

{% highlight swift %}
func upTo(_ n: UInt) -> [String] {
  if n == 0 { return [] }
  return [ "\(n)" ]
}
{% endhighlight %}

J'obtiens 98 erreurs de la forme : `-[TDDFizzBuzzTests.FizzBuzz_Spec test_Result_list_is_of_the_same_size_as_requested_upper_bound] : XCTAssertEqual failed: ("2") is not equal to ("1")`.

Je peux facilement d√©duire, √† partir du nom du test et du message, que le probl√®me ce situe au niveau de la taille de la liste.

Remettons le code de production en √©tat pour refaire passer le test :

{% highlight swift %}
func upTo(_ n: UInt) -> [String] {
  return (0...n).dropFirst(1).map { "\($0)" }
}
{% endhighlight %}

<p class="highlight">
Ce n'est pas parcequ'un test ne nous fait pas √©crire du code de prod qu'il est inutile. Un test est l√† pour <strong>sp√©cifier un comportement</strong> et sert √† la <strong>documentation du code</strong>.
</p>

### Deuxi√®me r√®gle m√©tier : les multiples de 3 donnent "Fizz"

Au regard des tests existants, j'ai mis √† jour ma liste :

<table>
  <tr><td>Pour les multiples de <code>3</code>, affiche <code>Fizz</code> au lieu du nombre</td></tr>
  <tr><td>Pour les multiples de <code>5</code>, affiche <code>Buzz</code> au lieu du nombre</td></tr>
  <tr><td>Pour les multiples de <code>15</code>, affiche <code>FizzBuzz</code> au lieu du nombre</td></tr>
  <tr><td>Afficher les nombres de 1 √† 100</td></tr>
</table>

J'ai supprim√© des exemples comme "3 -> [1, 2, Fizz]" car ils n'apportent rien en terme de documentation.

J'acc√©l√®re en passant directement aux r√®gles m√©tiers.

C'est parti pour le test de notre deuxi√®me r√®gle m√©tier :

{% highlight swift %}
func test_Multiples_of_3_are_displayed_as_Fizz() {
  let examples: [UInt] = [ 3, 6, 9, 12, 18, 3 * 123 ]
  for n in examples {
    assertThatFizzBuzz(upTo: n, endsWith: "Fizz")
  }
}
{% endhighlight %}

_Nous pourrions y aller par plus petites √©tapes en testant d'abord `3`, puis `6`, etc. Mais je me sens en confiance pour acc√©l√©rer un peu. Je sais que si jamais je n'y arrive pas, je pourrais ralentir._

Je vais en __GREEN__ le plus vite possible :

{% highlight swift %}
func upTo(_ n: UInt) -> [String] {
  return (0...n).dropFirst(1).map {
    if $0 % 3 == 0 {
      return "Fizz"
    }

    return "\($0)"
  }
}
{% endhighlight %}

> REFACTORING !

La m√©thode `upTo` commence √† devenir assez longue, c'est le smell [Long Method](https://refactoring.guru/smells/long-method).

Quel est le _traitement_ ?

> C'est [Extract Method](https://refactoring.guru/extract-method) !

Tout juste !

{% highlight swift %}
func upTo(_ n: UInt) -> [String] {
  return (0...n).dropFirst(1).map(stringFor)
}

private func stringFor(_ n: UInt) -> String {
  if n % 3 == 0 {
    return "Fizz"
  }

  return "\(n)"
}
{% endhighlight %}

J'aimerai aussi rendre plus explicite la condition pour vraiment faire ressortir la r√®gle m√©tier "multiple de 3".

On pourrait ajouter un _commentaire_ au dessus du `if` mais [les commentaires sont le signe que le code peut √™tre am√©lior√©](https://refactoring.guru/smells/comments).

L√† aussi, un [Extract Method](https://refactoring.guru/extract-method) √† la rescousse !

{% highlight swift %}
private func stringFor(_ n: UInt) -> String {
  if isMultipleOf3(n) {
    return "Fizz"
  }

  return "\(n)"
}

private func isMultipleOf3(_ n: UInt) -> Bool {
  return n % 3 == 0
}
{% endhighlight %}

Je pense encore pouvoir am√©lior√© la lisibilit√© du code en utilisant une super feature de Swift : les extensions !

{% highlight swift %}
struct FizzBuzz {

  // ...

  private func stringFor(_ n: UInt) -> String {
    if n.isMultipleOf3 {
      return "Fizz"
    }

    return "\(n)"
  }
}

extension UInt {  

  var isMultipleOf3: Bool {
    return self % 3 == 0
  }
}
{% endhighlight %}

L√† je suis content ! Passons au test suivant !

### Troisi√®me r√®gle m√©tier : les multiples de 5 donnent "Buzz"

<table>
  <tr><td>Pour les multiples de <code>5</code>, affiche <code>Buzz</code> au lieu du nombre</td></tr>
  <tr><td>Pour les multiples de <code>15</code>, affiche <code>FizzBuzz</code> au lieu du nombre</td></tr>
  <tr><td>Afficher les nombres de 1 √† 100</td></tr>
</table>

Le test :

{% highlight swift %}
func test_Multiples_of_5_are_displayed_as_Buzz() {
  let examples: [UInt] = [ 5, 10, 20, 25, 35, 5 * 124 ]
  for n in examples {
    assertThatFizzBuzz(upTo: n, endsWith: "Buzz")
  }
}
{% endhighlight %}

__RED__ ! Je le fais passer :

{% highlight swift %}
private func stringFor(_ n: UInt) -> String {
  if n.isMultipleOf3 {
    return "Fizz"
  }

  if n % 5 == 0 {
    return "Buzz"
  }

  return "\(n)"
}
{% endhighlight %}

__GREEN__ !

Et maintenant __REFACTORING__ !

D'abord le code de prod :

{% highlight swift %}
struct FizzBuzz {

  // ...

  private func stringFor(_ n: UInt) -> String {
    if n.isMultipleOf3 { return "Fizz" }
    if n.isMultipleOf5 { return "Buzz" }
    return "\(n)"
  }
}

extension UInt {

  // ...

  var isMultipleOf5: Bool {
    return self % 5 == 0
  }
}
{% endhighlight %}

Et enfin les tests, car je vois un pattern qui se r√©p√®te :
- une liste d'exemples,
- je parcours la liste,
- pour chaque √©l√©ment je v√©rifie que le r√©sultat termine par une `string` donn√©e.

Voil√† ce que √ßa donne :

{% highlight swift %}
func test_Multiples_of_3_are_displayed_as_Fizz() {
  assertThatAllFizzBuzzUpTo([ 3, 6, 9, 12, 18, UInt(3 * 123) ], endsWith: "Fizz")
}

func test_Multiples_of_5_are_displayed_as_Buzz() {
  assertThatAllFizzBuzzUpTo([ 5, 10, 20, 25, 35, UInt(5 * 124) ], endsWith: "Buzz")
}

private func assertThatAllFizzBuzzUpTo(_ examples: [UInt], endsWith expected: String, line: UInt = #line) {
  for n in examples {
    assertThatFizzBuzz(upTo: n, endsWith: expected, line: line)
  }
}
{% endhighlight %}

### Derni√®re r√®gle m√©tier : les multiples de 3 et 5 donnent "FizzBuzz"

<table>
  <tr><td>Pour les multiples de <code>15</code>, affiche <code>FizzBuzz</code> au lieu du nombre</td></tr>
  <tr><td>Afficher les nombres de 1 √† 100</td></tr>
</table>

> Nous y sommes presques !

Ouiii !! Mais ne crions pas victoire trop vite, il nous reste 2 testes √† impl√©menter.

Commen√ßons avec notre derni√®re r√®gle m√©tier.

{% highlight swift %}
func test_Multiples_of_3_and_5_are_displayed_as_FizzBuzz() {
  assertThatAllFizzBuzzUpTo([ 15, 30, 45, 60, 75, 90, UInt(3 * 5 * 125) ], endsWith: "FizzBuzz")
}
{% endhighlight %}

En route pour __GREEN__ !

{% highlight swift %}
private func stringFor(_ n: UInt) -> String {
  if n.isMultipleOf3 { return "Fizz" }
  if n.isMultipleOf5 { return "Buzz" }
  if n.isMultipleOf3 && n.isMultipleOf5 { return "FizzBuzz" }
  return "\(n)"
}
{% endhighlight %}

‚ùå __FAIL__

Oups, quoi ?

> H√©h√©, il faut mettre le trois√®me `if` avant les deux autres !

Ah mais oui, suis-je b√™te ? Merci !

_Heureusement qu'il y a les tests quand j'ai un coup de mou !_

Comme √ßa c'est mieux !

{% highlight swift %}
private func stringFor(_ n: UInt) -> String {
  if n.isMultipleOf3 && n.isMultipleOf5 { return "FizzBuzz" }
  if n.isMultipleOf3 { return "Fizz" }
  if n.isMultipleOf5 { return "Buzz" }
  return "\(n)"
}
{% endhighlight %}

Refactoring !

> Hum...je ne vois rien √† refactor...

Je trouve qu'il y a deux tests qui ne sont pas assez explicites.

> Ah ? Lesquels ?

`test_Multiples_of_3_are_displayed_as_Fizz` et `test_Multiples_of_5_are_displayed_as_Buzz`.

> Pourquoi ?

Je m'attends √† voir des multiples de 3 dans le premier, or je ne vois pas 15, on passe de 12 √† 18.

Et je m'attends √† voir des multiples de 5 dans le deuxi√®me, or je ne vois pas 15 non plus, on passe de 10 √† 20.

Le nom des tests ne refl√®te pas __exactement__ le besoin, il faut donc les renommer.

> Comme √ßa par exemple ?

{% highlight swift %}
func test_Multiples_of_3_but_not_5_are_displayed_as_Fizz() {
  // ...
}

func test_Multiples_of_5_but_not_3_are_displayed_as_Buzz() {
  // ...
}
{% endhighlight %}

Tout √† fait ! üëç

### Test d'acceptance : FizzBuzz de 1 √† 100

<table>
  <tr><td>Afficher les nombres de 1 √† 100</td></tr>
</table>

Bon, je ne sais pas toi mais √©crire les valeurs d'exemples pour ce test √† la main m'ennuie.

Tu as confiance dans nos tests ?

> Oui !

Et si on laissait ce dernier test √©chouer en nous donnant les valeurs ?

Ensuite on aura plus qu'√† copier le resultat donn√©e par le test dans notre test et le tour est jou√© !

> Genius ! ü§Ø

{% highlight swift %}
func test_Print_numbers_from_1_to_100() {
  assertThatFizzBuzz(upTo: 100, is: [])
}
{% endhighlight %}

‚ùå __FAIL__

Yeah ! Haha ! J'ai beaucoup trop de fun √† faire √ßa. ü§£

Et je copie les valeurs dans mon test :

{% highlight swift %}
func test_Print_numbers_from_1_to_100() {
  assertThatFizzBuzz(upTo: 100, is: [ "1", "2", "Fizz", "4", "Buzz", "Fizz", "7", "8", "Fizz", "Buzz", "11", "Fizz", "13", "14", "FizzBuzz", "16", "17", "Fizz", "19", "Buzz", "Fizz", "22", "23", "Fizz", "Buzz", "26", "Fizz", "28", "29", "FizzBuzz", "31", "32", "Fizz", "34", "Buzz", "Fizz", "37", "38", "Fizz", "Buzz", "41", "Fizz", "43", "44", "FizzBuzz", "46", "47", "Fizz", "49", "Buzz", "Fizz", "52", "53", "Fizz", "Buzz", "56", "Fizz", "58", "59", "FizzBuzz", "61", "62", "Fizz", "64", "Buzz", "Fizz", "67", "68", "Fizz", "Buzz", "71", "Fizz", "73", "74", "FizzBuzz", "76", "77", "Fizz", "79", "Buzz", "Fizz", "82", "83", "Fizz", "Buzz", "86", "Fizz", "88", "89", "FizzBuzz", "91", "92", "Fizz", "94", "Buzz", "Fizz", "97", "98", "Fizz", "Buzz" ])
}
{% endhighlight %}

‚úÖ __SUCCESS__

Tadaaaa ! üéâ

## Conclusion

## Pour aller plus loin
